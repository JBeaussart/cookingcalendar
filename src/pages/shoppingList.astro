---
import Layout from "../layouts/Layout.astro";
---

<Layout title="Liste de courses">
  <div class="min-h-screen bg-gradient-to-br from-slate-50 to-slate-100">
    <div class="mx-auto max-w-3xl px-4 py-12">
      <!-- Header -->
      <div class="mb-8 text-center">
        <h1 class="text-4xl font-bold text-slate-900 mb-2">Ma liste</h1>
        <p class="text-slate-600">N'oubliez rien pour vos recettes !</p>
      </div>

      <!-- Actions & Add Form -->
      <div class="mb-8 space-y-6">
        <!-- Bulk Actions -->
        <div class="flex justify-center gap-3">
          <button
            id="btnCheckAll"
            type="button"
            class="inline-flex items-center gap-2 rounded-xl bg-white px-4 py-2 text-sm font-medium text-slate-700 shadow-sm ring-1 ring-slate-200 transition hover:bg-slate-50 hover:text-blue-600 active:scale-95"
          >
            <svg
              class="h-4 w-4"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
            >
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                stroke-width="2"
                d="M5 13l4 4L19 7"></path>
            </svg>
            Tout cocher
          </button>
          <button
            id="btnUncheckAll"
            type="button"
            class="inline-flex items-center gap-2 rounded-xl bg-white px-4 py-2 text-sm font-medium text-slate-700 shadow-sm ring-1 ring-slate-200 transition hover:bg-slate-50 hover:text-blue-600 active:scale-95"
          >
            <svg
              class="h-4 w-4"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
            >
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                stroke-width="2"
                d="M6 18L18 6M6 6l12 12"></path>
            </svg>
            Tout décocher
          </button>
        </div>

        <!-- Add Form -->
        <form id="addForm" class="flex flex-col sm:flex-row gap-3">
          <div class="relative flex-1">
            <input
              id="fItem"
              type="text"
              placeholder="Ajouter un article..."
              class="w-full rounded-xl border border-slate-200 bg-white px-4 py-3 pl-11 text-sm focus:outline-none focus:ring-2 focus:ring-blue-500 shadow-sm"
              required
            />
            <div
              class="pointer-events-none absolute inset-y-0 left-0 flex items-center pl-4 text-slate-400"
            >
              <svg
                class="h-5 w-5"
                fill="none"
                stroke="currentColor"
                viewBox="0 0 24 24"
              >
                <path
                  stroke-linecap="round"
                  stroke-linejoin="round"
                  stroke-width="2"
                  d="M12 4v16m8-8H4"></path>
              </svg>
            </div>
          </div>
          <input
            id="fQty"
            type="number"
            step="any"
            placeholder="Qté"
            class="w-full sm:w-24 rounded-xl border border-slate-200 bg-white px-4 py-3 text-sm focus:outline-none focus:ring-2 focus:ring-blue-500 shadow-sm"
          />
          <button
            type="submit"
            class="inline-flex items-center justify-center rounded-xl bg-blue-600 px-6 py-3 text-sm font-bold text-white shadow-lg shadow-blue-600/30 transition-all hover:bg-blue-700 hover:shadow-xl hover:scale-105 active:scale-95"
          >
            Ajouter
          </button>
        </form>
      </div>

      <!-- List Container -->
      <div
        class="rounded-3xl bg-white shadow-xl shadow-slate-200/50 overflow-hidden ring-1 ring-slate-100 mb-20 sm:mb-0"
      >
        <ul id="list" class="divide-y divide-slate-100"></ul>

        <!-- Empty State (handled in JS, but default hidden here) -->
        <div id="emptyState" class="hidden p-12 text-center">
          <div
            class="mx-auto mb-4 flex h-16 w-16 items-center justify-center rounded-full bg-slate-50"
          >
            <svg
              class="h-8 w-8 text-slate-300"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
            >
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                stroke-width="2"
                d="M3 3h2l.4 2M7 13h10l4-8H5.4M7 13L5.4 5M7 13l-2.293 2.293c-.63.63-.184 1.707.707 1.707H17m0 0a2 2 0 100 4 2 2 0 000-4zm-8 2a2 2 0 11-4 0 2 2 0 014 0z"
              ></path>
            </svg>
          </div>
          <h3 class="text-lg font-medium text-slate-900">
            Votre liste est vide
          </h3>
          <p class="mt-1 text-slate-500">
            Ajoutez des recettes au planning ou des articles manuellement.
          </p>
        </div>
      </div>

      <p
        id="status"
        class="mt-4 text-center text-sm font-medium text-slate-400"
      >
      </p>
    </div>
  </div>

  <script type="module">
    const listEl = document.getElementById("list");
    const emptyStateEl = document.getElementById("emptyState");
    const statusEl = document.getElementById("status");
    const btnCheckAll = document.getElementById("btnCheckAll");
    const btnUncheckAll = document.getElementById("btnUncheckAll");
    const addForm = document.getElementById("addForm");
    const fItem = document.getElementById("fItem");
    const fQty = document.getElementById("fQty");

    let computed = [];
    let saved = [];
    let customs = [];
    let items = [];

    const SECTION_FALLBACK = "Autres recettes";
    const SECTION_CUSTOM = "Divers";

    function normalizeTitle(input) {
      const t = String(input || "").trim();
      return t || SECTION_FALLBACK;
    }

    function decorateCustomItem(it) {
      return {
        ...it,
        sectionKey: "2:custom",
        sectionLabel: SECTION_CUSTOM,
      };
    }

    function makeSectionKey(title) {
      return `1:${normalizeTitle(title).toLowerCase()}`;
    }

    const makeKey = (it) =>
      `${String(it.item || "")
        .trim()
        .toLowerCase()}|||${String(it.unit || "")
        .trim()
        .toLowerCase()}`;

    function makeEntryKey(entry, ref) {
      const base = makeKey(entry);
      const refId =
        typeof ref?.id === "string" && ref.id.trim() ? ref.id.trim() : "";
      if (refId) {
        return `${base}||recipe:${refId}`;
      }
      const label = normalizeTitle(
        ref?.title || entry.primaryRecipe || SECTION_FALLBACK,
      );
      return `${base}||title:${label.toLowerCase()}`;
    }

    function expandComputedEntry(entry, savedChecked) {
      const baseKey = makeKey(entry);
      const totalQuantity = Number.isFinite(entry.quantity)
        ? entry.quantity
        : undefined;

      const rawRefs = Array.isArray(entry.recipes) ? entry.recipes : [];
      const refs = rawRefs.length
        ? rawRefs
        : [
            {
              id: null,
              title: entry.primaryRecipe || SECTION_FALLBACK,
              quantity: totalQuantity,
            },
          ];

      return refs
        .map((ref) => {
          const label = normalizeTitle(ref?.title);
          const entryKey = makeEntryKey(entry, {
            id: ref?.id,
            title: label,
          });
          const isChecked =
            (savedChecked && savedChecked.get(entryKey)) ??
            (savedChecked && savedChecked.get(baseKey)) ??
            false;
          return {
            source: "computed",
            item: entry.item,
            unit: entry.unit,
            quantity: Number.isFinite(ref?.quantity)
              ? ref.quantity
              : totalQuantity,
            checked: isChecked,
            sectionKey: makeSectionKey(label),
            sectionLabel: label,
            baseKey,
            baseQuantity: totalQuantity,
            entryKey,
            recipeId:
              typeof ref?.id === "string" && ref.id.trim()
                ? ref.id.trim()
                : null,
          };
        })
        .sort((a, b) => a.sectionLabel.localeCompare(b.sectionLabel, "fr"));
    }

    const JSON_HEADERS = { "content-type": "application/json" };

    function serializeComputedItems() {
      const seen = new Map();
      const result = [];
      items
        .filter((it) => it.source === "computed")
        .forEach((it) => {
          const unitValue = typeof it.unit === "string" ? it.unit : "";
          const payload = {
            item: it.item,
            unit: unitValue,
            checked: !!it.checked,
          };
          if (Number.isFinite(it.baseQuantity)) {
            payload.quantity = it.baseQuantity;
          }
          if (typeof it.entryKey === "string" && it.entryKey) {
            payload.entryKey = it.entryKey;
          }
          const key = payload.entryKey || makeKey(it);
          if (!seen.has(key)) {
            seen.set(key, payload);
            result.push(payload);
          } else if (payload.checked) {
            const ref = seen.get(key);
            ref.checked = true;
          }
        });
      return result;
    }

    function serializeCustomItems() {
      return items
        .filter((it) => it.source === "custom")
        .map((it) => ({
          item: it.item,
          checked: !!it.checked,
          ...(it.unit ? { unit: it.unit } : {}),
        }));
    }

    function updateBulkButtons() {
      const hasItems = Array.isArray(items) && items.length > 0;
      const noneChecked = !hasItems || items.every((it) => !it.checked);

      const toggleState = (btn, disable) => {
        if (!btn) return;
        btn.disabled = disable;
        btn.classList.toggle("opacity-50", disable);
        btn.classList.toggle("cursor-not-allowed", disable);
      };

      toggleState(btnCheckAll, !hasItems || !items.some((it) => !it.checked));
      toggleState(btnUncheckAll, !hasItems || noneChecked);
    }

    async function applyBulkCheck(nextChecked) {
      if (!items.length) return;

      const prev = items.map((it) => ({ ...it }));
      items = items.map((it) => ({ ...it, checked: nextChecked }));
      render();

      status(nextChecked ? "Cochement..." : "Décochage...");

      try {
        const computedPayload = serializeComputedItems();
        const customPayload = serializeCustomItems();

        const requests = [];
        if (computedPayload.length) {
          requests.push(
            fetch("/api/save-shopping-totals", {
              method: "POST",
              headers: JSON_HEADERS,
              body: JSON.stringify({ items: computedPayload }),
            }),
          );
        }

        for (const payload of customPayload) {
          requests.push(
            fetch("/api/custom-items", {
              method: "PATCH",
              headers: JSON_HEADERS,
              body: JSON.stringify(payload),
            }),
          );
        }

        const responses = await Promise.all(requests);
        const failed = responses.find((res) => res && !res.ok);
        if (failed) throw new Error("Erreur bulk toggle");

        status("✅ Sauvegardé");
      } catch (e) {
        console.error(e);
        items = prev;
        render();
        status("❌ Erreur d'enregistrement");
      }
    }

    function sortItems() {
      items.sort((a, b) => {
        // 1. Checked status (unchecked first)
        if (a.checked !== b.checked) return a.checked ? 1 : -1;

        // 2. Section
        const keyA = a.sectionKey || "";
        const keyB = b.sectionKey || "";
        if (keyA !== keyB) return keyA.localeCompare(keyB, "fr");

        // 3. Name
        return String(a.item || "").localeCompare(String(b.item || ""), "fr");
      });
    }

    function render() {
      sortItems();
      listEl.innerHTML = "";
      updateBulkButtons();

      if (!Array.isArray(items) || items.length === 0) {
        listEl.classList.add("hidden");
        emptyStateEl.classList.remove("hidden");
        return;
      } else {
        listEl.classList.remove("hidden");
        emptyStateEl.classList.add("hidden");
      }

      let currentSectionKey = null;

      items.forEach((row, idx) => {
        const isCustom = row.source === "custom";
        let sectionKey = row.sectionKey || (isCustom ? "2:custom" : "1:autres");
        let sectionLabel =
          row.sectionLabel || (isCustom ? SECTION_CUSTOM : SECTION_FALLBACK);

        // Group checked items at the bottom
        if (row.checked) {
          sectionKey = "ZZ:checked";
          sectionLabel = "Terminé";
        }

        if (sectionKey !== currentSectionKey) {
          currentSectionKey = sectionKey;
          const header = document.createElement("li");
          header.className =
            "bg-slate-50/80 px-5 py-3 text-xs font-bold uppercase tracking-wider text-slate-500 border-b border-slate-100 sticky top-0 backdrop-blur-sm z-10";

          if (sectionKey === "2:custom") {
            const wrap = document.createElement("div");
            wrap.className = "flex items-center justify-between gap-3";

            const title = document.createElement("span");
            title.textContent = sectionLabel;
            wrap.appendChild(title);

            const btn = document.createElement("button");
            btn.type = "button";
            btn.className =
              "rounded-lg bg-rose-50 px-3 py-1 text-[10px] font-bold uppercase tracking-wide text-rose-600 transition hover:bg-rose-100 hover:text-rose-700";
            btn.textContent = "Tout supprimer";

            btn.addEventListener("click", async () => {
              if (!items.some((it) => it.source === "custom")) return;
              const confirmDelete = window.confirm(
                "Supprimer tous les éléments ajoutés manuellement ?",
              );
              if (!confirmDelete) return;

              status("Suppression...");
              btn.disabled = true;
              btn.classList.add("opacity-60", "cursor-not-allowed");
              try {
                const res = await fetch("/api/custom-items?all=1", {
                  method: "DELETE",
                });
                if (!res.ok) throw new Error("Suppression échouée");
                await load();
                status("✅ Supprimé");
              } catch (e) {
                console.error(e);
                status("❌ Erreur de suppression");
              } finally {
                btn.disabled = false;
                btn.classList.remove("opacity-60", "cursor-not-allowed");
              }
            });

            wrap.appendChild(btn);
            header.appendChild(wrap);
          } else {
            header.textContent = sectionLabel;
          }

          listEl.appendChild(header);
        }

        const hasQty = typeof row.quantity === "number" && !isNaN(row.quantity);
        const txt = hasQty
          ? `${row.item} : ${row.quantity}${row.unit ? " " + row.unit : ""}`
          : row.item;

        const li = document.createElement("li");
        li.className =
          "group flex items-center justify-between gap-4 px-5 py-4 hover:bg-slate-50 transition duration-200";

        // Gauche : checkbox + libellé
        const left = document.createElement("label");
        left.className =
          "flex items-center gap-4 cursor-pointer select-none flex-1 min-w-0";

        const cb = document.createElement("input");
        cb.type = "checkbox";
        cb.dataset.idx = String(idx);
        cb.checked = !!row.checked;
        cb.className =
          "peer h-5 w-5 shrink-0 rounded-lg border-slate-300 text-blue-600 focus:ring-offset-0 focus:ring-2 focus:ring-blue-500 transition cursor-pointer";

        const labelWrapper = document.createElement("div");
        labelWrapper.className = "flex flex-col min-w-0";

        const mainText = document.createElement("span");
        mainText.className =
          "text-sm font-medium truncate transition-colors duration-200 " +
          (cb.checked ? "line-through text-slate-400" : "text-slate-700");
        mainText.textContent = txt;
        labelWrapper.appendChild(mainText);

        left.appendChild(cb);
        left.appendChild(labelWrapper);

        // Droite : actions
        const right = document.createElement("div");
        right.className = "flex items-center gap-2";

        if (isCustom) {
          const del = document.createElement("button");
          del.type = "button";
          del.className =
            "del-btn flex h-8 w-8 items-center justify-center rounded-lg text-slate-400 hover:bg-rose-50 hover:text-rose-600 transition opacity-0 group-hover:opacity-100";
          del.dataset.idx = String(idx);
          del.title = "Supprimer";
          del.innerHTML =
            '<svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 24 24" fill="none" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6M9 7h6m1 0H8m8 0l-1-3H9L8 7" /></svg>';
          right.appendChild(del);
        }

        li.appendChild(left);
        li.appendChild(right);
        listEl.appendChild(li);
      });

      // Gestion des checkboxes
      listEl.querySelectorAll('input[type="checkbox"]').forEach((cb) => {
        cb.addEventListener("change", async () => {
          const i = Number(cb.dataset.idx);
          const target = items[i];
          if (!target) return;

          // Update UI immediately
          const textSpan = cb.nextElementSibling.querySelector("span");
          if (cb.checked) {
            textSpan.classList.add("line-through", "text-slate-400");
            textSpan.classList.remove("text-slate-700");
          } else {
            textSpan.classList.remove("line-through", "text-slate-400");
            textSpan.classList.add("text-slate-700");
          }

          if (target.source === "computed") {
            const entryKey =
              typeof target.entryKey === "string" && target.entryKey
                ? target.entryKey
                : null;
            if (entryKey) {
              items = items.map((it) =>
                it.source === "computed" && it.entryKey === entryKey
                  ? { ...it, checked: cb.checked }
                  : it,
              );
            } else {
              items[i] = { ...target, checked: cb.checked };
            }
          } else {
            items[i] = { ...target, checked: cb.checked };
          }

          // Re-render to move item to bottom
          render();

          status("Enregistrement...");

          try {
            if (target.source === "custom") {
              await fetch("/api/custom-items", {
                method: "PATCH",
                headers: { "content-type": "application/json" },
                body: JSON.stringify({
                  item: target.item,
                  checked: cb.checked,
                }),
              });
            } else {
              const payload = serializeComputedItems();

              await fetch("/api/save-shopping-totals", {
                method: "POST",
                headers: { "content-type": "application/json" },
                body: JSON.stringify({ items: payload }),
              });
            }
            status("✅ Sauvegardé");
          } catch (e) {
            console.error(e);
            status("❌ Erreur d'enregistrement");
          }
        });
      });

      // Suppression des custom
      listEl.querySelectorAll(".del-btn").forEach((btn) => {
        btn.addEventListener("click", async () => {
          const i = Number(btn.dataset.idx);
          const it = items[i];
          if (!it || it.source !== "custom") return;
          status("Suppression...");
          try {
            const params = new URLSearchParams({ item: it.item });
            const r = await fetch(`/api/custom-items?${params.toString()}`, {
              method: "DELETE",
            });
            await r.json();
            await load();
            status("✅ Supprimé");
          } catch (e) {
            console.error(e);
            status("❌ Erreur de suppression");
          }
        });
      });
    }

    function status(t) {
      statusEl.textContent = t || "";
    }

    async function load() {
      status("Chargement...");
      try {
        const [r1, r2, r3] = await Promise.all([
          fetch("/api/compute-shopping-totals"),
          fetch("/api/save-shopping-totals"),
          fetch("/api/custom-items"),
        ]);
        const [j1, j2, j3] = await Promise.all([
          r1.json(),
          r2.json(),
          r3.json(),
        ]);

        const rawComputed = Array.isArray(j1.items) ? j1.items : [];
        const rawCustoms = Array.isArray(j3.items) ? j3.items : [];

        saved = Array.isArray(j2.items) ? j2.items : [];

        const savedChecked = new Map();
        for (const s of saved) {
          const state = !!s.checked;
          const entryKey =
            typeof s.entryKey === "string" && s.entryKey.trim()
              ? s.entryKey.trim()
              : "";
          if (entryKey) {
            savedChecked.set(entryKey, state);
          }
          const base = makeKey(s);
          if (!savedChecked.has(base) || state) {
            savedChecked.set(base, state);
          }
        }

        computed = rawComputed.flatMap((entry) =>
          expandComputedEntry(entry, savedChecked),
        );

        customs = rawCustoms.map((it) =>
          decorateCustomItem({ ...it, source: "custom" }),
        );

        items = [...computed, ...customs];

        status("OK");
        render();
      } catch (e) {
        console.error(e);
        status("❌ Erreur de chargement");
      }
    }

    // Ajout custom
    addForm.addEventListener("submit", async (e) => {
      e.preventDefault();
      const item = fItem.value.trim();
      const qtyRaw = fQty.value.trim();
      if (!item) return;

      status("Ajout...");
      try {
        const payload = { item };
        if (qtyRaw !== "") payload.quantity = Number(qtyRaw);

        await fetch("/api/custom-items", {
          method: "POST",
          headers: { "content-type": "application/json" },
          body: JSON.stringify(payload),
        });

        fItem.value = "";
        fQty.value = "";
        await load();
        status("✅ Ajouté");
      } catch (e) {
        console.error(e);
        status("❌ Erreur d'ajout");
      }
    });

    btnCheckAll?.addEventListener("click", () => {
      if (!items.length || items.every((it) => it.checked)) return;
      applyBulkCheck(true);
    });

    btnUncheckAll?.addEventListener("click", () => {
      if (!items.length || items.every((it) => !it.checked)) return;
      applyBulkCheck(false);
    });

    await load();
  </script>
</Layout>
